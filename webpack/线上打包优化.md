1. 生产模式默认用mode:'production'让webpack应用默认的优化, 使用TerserPlugin和OptimizeCSSAssetsPlugin对js和css进行压缩
```javascript
module.exports = {
  mode: 'production',
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    publicPath: '/'
  },
  optimization: {
    minimize: true,
    minimizer: [
      // 使用 TerserPlugin 和 OptimizeCSSAssetsPlugin 进行压缩
      new TerserPlugin(),
      new OptimizeCSSAssetsPlugin({})
    ]
  }
};
```
2. 使用splitChunkPlugin自动分割代码
```javascript
{
  optimization: {
    splitChunks: {
      chunks: 'all',
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all'
      }
    }
  }
}
```

3. 使用external加载外部资源

4. 路由使用webpackChunkName 来标记, webpack 会根据这个标记来生成对应的文件名, 进行分包

5. 确保使用ES6语法,便于webpack进行tree-shaking,确保使用的类库都支持tree-shaking, 典型的例子是用lodash-es来替代lodash

6. 代码中使用import函数来动态引入某个模块 import('./module').then(module => module.default());

7. 如果服务器端支持Gzip压缩, webpack在打包的时候可以启用Gzip压缩
```Nginx
http {
    gzip on;
    # 其他配置...
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}
```
```javascript
// webpack.config.js
const CompressionWebpackPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [
    new CompressionWebpackPlugin({
      algorithm: 'gzip',
      test: /\.js$|\.css$|\.html$/,
      threshold: 10240,
      minRatio: 0.8
    })
  ],
  //...
};
```

8. 使用DllPlugin和DllReferencePlugin提前编译第三库,以加快构建速度

```javascript
// webpack.dll.config.js
const path = require('path');

module.exports = {
  entry: {
    vendor: ['react', 'react-dom', 'lodash-es']
  },
  output: {
    library: '[name]_[hash]',
    path: path.resolve(__dirname, 'dll'),
    filename: '[name].dll.js'
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dll', '[name]-manifest.json'),
      name: '[name]_[hash]'
    })
  ]
};

// webpack.config.js
const path = require('path');

module.exports = {
  //...
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: require('./dll/vendor-manifest.json')
    })
  ],
  //...
};
```
9. 使用cache-loader缓存中间编译结果

```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: [
          'cache-loader', // 缓存 loader
          'babel-loader' // 编译 JS
        ]
      }
    ]
  },
  //...
};
```

10. 使用 HappyPack 或 thread-loader 利用多核 CPU 进行并行编译。
```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: [
          {
            loader: 'thread-loader', // 并行处理
            options: {
              workers: 4 // 使用 4 个线程
            }
          },
          'babel-loader' // 编译 JS
        ]
      }
    ]
  },
  //...
};
```

11. 使用webpack-bundle-analyzer分析打包结构, 进行有针对性的优化