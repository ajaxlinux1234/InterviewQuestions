# xss跨站脚本攻击
问题: xss是指攻击者通过注入恶意脚本来利用信任网站向用户提供恶意内容

应对策略:
1. 输入验证: 对用户提交的数据进行严格验证, 确保数据符合预期格式

2. 对HTML转义: 在输出HTML之前对用户输入的数据进行转义

3. CSP(content security policy): 设置内容安全策略, 限制页面可以从哪些源加载资源

 ### node端使用helmet库解决xss攻击

 ```javascript
  const express = require('express');
  const helmet = require('helmet');
  const app = express();

  app.use(helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:'],
      frameAncestors: ["'none'"],
      objectSrc: ["'none'"],
      baseUri: ["'self'"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      mediaSrc: ["'self'"],
      manifestSrc: ["'self'"],
      workerSrc: ["'self'", 'blob:'],
      childSrc: ["'none'"],
      formAction: ["'self'"],
    },
  }));
 ```

 ### 客户端可以通过生成uuid来使用动态CSP

 ```
  const nonce = crypto.randomUUID();
  document.querySelector('head').innerHTML += `
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'nonce-${nonce}';">
  `;
  document.querySelector('script').setAttribute('nonce', nonce);
 ```

4. HTTPOnly cookies: 设置HTTPOnly标识, 防止js访问cookie
```javascript
const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();

app.use(cookieParser());

app.get('/set-cookie', (req, res) => {
  res.cookie('session', 'abc123', { httpOnly: true, secure: true, sameSite: 'strict' });
  res.send('Cookie set');
});
```

5. SameSite cookies: 设置SameSite属性, 防止跨站请求伪造攻击

```javascript
const express = require('express');
const cookieParser = require('cookie-parser');
const app = express();

app.use(cookieParser());

app.get('/set-cookie', (req, res) => {
  res.cookie('session', 'abc123', { httpOnly: true, secure: true, sameSite: 'strict' });
  res.send('Cookie set');
});
```

# 跨站请求伪造（CSRF）, 伪装成合法用户的请求执行恶意操作, 如修改密码,转账

1. CSRF Token: 使用CSRF令牌来进行请求验证, 确保请求的来源可信
```javascript
const express = require('express');
const crypto = require('crypto');
const session = require('express-session');

const app = express();
app.use(express.urlencoded({ extended: true })); // 解析请求体
app.use(session({
  secret: 'secret-key',
  resave: false,
  saveUninitialized: true
}));

// 生成 CSRF 令牌
function generateCsrfToken() {
  return crypto.randomBytes(16).toString('hex'); // 生成 32 字节的随机字符串
}

// 设置 CSRF 令牌
app.get('/csrf-token', (req, res) => {
  const csrfToken = generateCsrfToken();
  req.session.csrfToken = csrfToken;
  res.json({ csrfToken });
});

// 处理需要 CSRF 保护的 POST 请求
app.post('/protected-endpoint', (req, res) => {
  const csrfTokenFromSession = req.session.csrfToken;
  const csrfTokenFromRequest = req.body._csrf;

  if (csrfTokenFromSession === csrfTokenFromRequest) {
    // CSRF 令牌匹配，请求合法
    res.status(200).send('Request processed successfully.');
  } else {
    // CSRF 令牌不匹配，拒绝请求
    res.status(403).send('CSRF token mismatch.');
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CSRF Token Example</title>
</head>
<body>
  <form action="/protected-endpoint" method="POST">
    <input type="hidden" name="_csrf" value="{{ csrfToken }}">
    <label for="username">Username:</label>
    <input type="text" id="username" name="username"><br><br>
    <label for="password">Password:</label>
    <input type="password" id="password" name="password"><br><br>
    <button type="submit">Submit</button>
  </form>
</body>
</html>
```
2. SameSite Cookies: 设置SameSite属性, 防止跨站请求伪造攻击
3. 双重认证: 对于敏感操作,增加二次验证机制,如短信验证码或双因素认证


# 点击劫持: 是指将透明层和伪装层覆盖在目标按钮之上, 欺骗用户点击

应对策略:
1. 设计HTTP响应头: X-Frame-Options: SAMEORIGIN 或DENY, 防止页面被嵌入到iframe中
```javascript
const express = require('express');
const helmet = require('helmet');

const app = express();

// 设置 X-Frame-Options 为 DENY
app.use(helmet.frameguard({ action: 'deny' }));

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});
```
2. 通过设置CSP

```javascript
const express = require('express');
const helmet = require('helmet');

const app = express();

// 设置 Content-Security-Policy 的 frame-ancestors 指令
app.use(helmet.contentSecurityPolicy({
  directives: {
    frameAncestors: ["'none'"],
    ...helmet.contentSecurityPolicy.getDefaultDirectives(),
  },
}));

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});

frame-ancestors 'none'：不允许任何页面将当前页面嵌入到 <iframe> 中。
frame-ancestors 'self'：只允许当前页面的父页面将当前页面嵌入到 <iframe> 中。
frame-ancestors <uri>：只允许指定的源将当前页面嵌入到 <iframe> 中。

```

# SQL注入: SQL 注入是指攻击者通过在输入字段中插入恶意 SQL 语句来操纵数据库。

参数化查询：使用预编译语句（如 SQL 参数化查询），避免直接拼接用户输入。
输入验证：对用户输入进行验证，确保其符合预期格式。
ORM 框架：使用 ORM 框架如 Sequelize 或 Mongoose，它们内置了 SQL 注入防护机制。

# 信息泄漏: 应用可能无意间会暴漏敏感信息,如错误消息,堆栈跟踪

错误处理: 自定义错误处理, 避免暴漏敏感信息
日志记录: 禁止在日志中记录敏感信息,如密码、token等
敏感信息过滤: 在发送到服务器的数据中过滤掉敏感信息

# 安全传输层协议: 未加密的数据可能被截获, 导致数据泄漏

使用HTTPS

# 社会工程学攻击: 利用人类心理弱点来进行欺诈或者获取敏感信息的行为

1. 用户教育: 定期对用户进行安全教育培训, 教育用户如何识别和防范钓鱼邮件和其他诈骗手段
2. 多因素认证(MFA): 实施多因素认证机制, 提高账户安全性





