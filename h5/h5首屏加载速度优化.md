# 1.优化资源请求

## 减少HTTP请求次数
1. 合并文件: 合并js和css文件, 减少HTTP请求次数
2. 内联小文件:把小的图标或字体可转成base64内联到js或css中

## 使用HTTP/2和HTTP/3: 这些协议支持多路复用,减少延迟, 确保所有的资源都已进行了压缩和优化

```Nginx
http {
    # 其他配置
    server {
        listen 443 ssl http2; # 指定使用HTTPS和HTTP/2
        server_name example.com;

        # SSL证书配置
        ssl_certificate /etc/nginx/ssl/example.com.crt;
        ssl_certificate_key /etc/nginx/ssl/example.com.key;

        # 其他SSL相关配置

        location / {
            root /var/www/html;
            index index.html index.htm;
        }
    }
}
```





# 2.资源缓存
设置合适的缓存策略
静态资源缓存: 为静态资源设置长缓存时间, 减少重复加载
使用ETag或control-cache: 确保浏览器可以利用缓存资源而不是每次都请求服务器

## 设置Cache-Control
```Nginx
http {
    # 其他配置

    server {
        listen       80;
        server_name  example.com www.example.com;
        return 301 https://$host$request_uri;
    }

    server {
        listen       443 ssl;
        server_name  example.com www.example.com;

        ssl_certificate /etc/nginx/ssl/example.com.crt;
        ssl_certificate_key /etc/nginx/ssl/example.com.key;

        location ~* \.(ico|pdf|flv|jpg|jpeg|png|gif|js|css|swf)$ {
            expires 30d; # 设置缓存时间为30天
            add_header Cache-Control public;
        }

        location ~* \.(php|jsp|aspx|cfm)$ {
            expires off; # 动态内容不缓存
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Pragma "no-cache";
            add_header Expires "0";
        }

        # 其他配置
    }
}
```

## 设置ETag
```Nginx
http {
    # 其他配置

    server {
        # 其他配置

        # 设置ETags
        etag on;
    }
}
```

## Last-modified表示资源的最后修改时间.浏览器会带上if-modified-since,服务器会检查最后修改时间一致否，一致则返回304，不一致则返回200

```
http {
    # 其他配置

    server {
        # 其他配置

        # 设置Last-Modified
        expires 30d;
        expires_not_modified on;
    }
}
```

## 前端代码资源缓存

1. 在文件url query中加哈希值,避免请求旧的文件
2. 在文件名中加入版本号可以实现更细粒度的缓存控制





# 3.优化图片和媒体资源

## 图片优化
1. 压缩图片: 使用图像压缩工具(如TinyPNG, ImageOptim)来减少图片大小
2. 使用webP格式: webP格式比JPEG和PNG体积更小,质量更好。
3. 懒加载: 使用懒加载技术, 仅在图片进入视口时才加载

## 视频优化
1. 延迟加载视频: 将视频延迟加载直到用户滚动到视频区域
2. 使用流媒体技术逐步加载视频, 减少初始化加载时间, 生成并配置M3U8文件, 或者MPD文件
```Nginx
ffmpeg -i input.mp4 -hls_time 10 -hls_list_size 0 -hls_segment_filename output_%03d.ts output.m3u8

server {
    listen 80;
    server_name example.com;

    location /videos/ {
        alias /data/videos/;
        add_header Cache-Control "public, max-age=86400";
        add_header Content-Type "application/vnd.apple.mpegurl";

        # 开启Range请求支持
        add_header Accept-Ranges bytes always;
    }
}
```

```html
<video controls>
    <source src="https://example.com/videos/output.m3u8" type="application/x-mpegURL">
    <source src="https://example.com/videos/output.mpd" type="application/dash+xml">
    Your browser does not support the video tag.
</video>
```



# 4.使用CDN, 把一些公共的依赖vue, element放到CDN上, 利用CDN的缓存, 增加页面打开速度

# 5. 代码优化
压缩和合并: 使用UglifyJS压缩js和css, 多个css和js合并为一个文件,减少请求次数

```javascript
{
  "name": "your-project",
  "version": "1.0.0",
  "scripts": {
    "build": "terser ./src/main.js -o ./dist/bundle.min.js --compress --mangle",
    "build-css": "cleancss ./src/styles.css -o ./dist/styles.min.css"
  },
  "devDependencies": {
    "terser": "^5.15.1"
  }
}
```

代码分割: 使用webpack的代码分割功能, 将代码拆分为多个模块, 减少初始加载时间

```javascript
npm install webpack webpack-cli --save-dev
npm install splitChunks-plugin --save-dev

const path = require('path');
const webpack = require('webpack');
const SplitChunksPlugin = require('splitChunks-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
      minSize: 10000,
      maxSize: 250000,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
  plugins: [
    new SplitChunksPlugin({
      maxSize: 250000,
    }),
  ],
};
```

异步加载非关键资源: 将一些非关键资源异步加载提高首屏加载速度 

```html
<script src="bundle.js" async></script>
<!-- 或者 -->
<script src="bundle.js" defer></script>
```

# 6.首屏渲染优化

## 使用预渲染,预渲染首屏内容,减少Dom构建时间
vue使用nuxt.js react使用next.js

## 关键路径优化:确保优先加载首屏资源

1. Chrome DevTools 的Network Tab 刷新页面，观察哪些资源的加载时间最长。想办法优化或者延迟加载
2. 提取关键样式到头部style标签中, 减少外部css文件的加载
3. 使用link preload预加载关键的css js资源
4. 使用script async 或 script defer加载非关键资源
5. script async会在异步加载后立即执行. 适用于哪些广告脚本或对其他页面没有直接影响的脚本, 执行时dom可能未加载完成
6. script defer加载后不会立即执行, 且多个script defer会保留执行顺序, 适用于需要在页面渲染完成立即执行的脚本, 执行时dom已加载完成

# 7. 减少dom操作
1. 在js代码中减少高频率的dom, 多个dom操作可用document.createDocumentFragment()合并成一个dom操作
2. 利用vue或react的虚拟dom机制, 减少dom的实际更新次数

# 8.浏览器缓存优化
1. 设置正确的Cache-Control头,使浏览器能够缓存资源
2. 使用ETag来判断浏览器是否需要重新请求资源

# 9.预加载资源
1. <link rel="preload" />提前预加载关键资源如css
2. <link rel="prefetch" />提前下载后续可能会用到的资源
3. <link rel="dns-prefetch" />预解析DNS

# 10.使用Service worker
1. 缓存关键资源: 使用Service worker缓存静态资源, 提高离线访问性能


