<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>自定义 Vue3 响应式实现 (完整修复版)</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
        min-height: 100vh;
        padding: 20px;
        color: #333;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      header {
        background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
        color: white;
        padding: 20px 30px;
        text-align: center;
      }

      h1 {
        font-size: 2.2rem;
        margin-bottom: 10px;
        background: linear-gradient(to right, #4ecdc4, #44a08d);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .subtitle {
        color: #a8d0e6;
        font-size: 1.1rem;
      }

      .content {
        padding: 30px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
      }

      .demo-section {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        border: 1px solid #eaeaea;
      }

      h2 {
        color: #2c3e50;
        border-bottom: 2px solid #4ecdc4;
        padding-bottom: 10px;
        margin-bottom: 20px;
      }

      .data-display {
        background: white;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        border: 1px solid #ddd;
        font-family: "Courier New", monospace;
        min-height: 150px;
      }

      .highlight {
        color: #ff6b6b;
        font-weight: bold;
      }

      .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        padding: 10px 16px;
        background: #4ecdc4;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
      }

      button:hover {
        background: #44a08d;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      button.danger {
        background: #ff6b6b;
      }

      button.danger:hover {
        background: #ee5a52;
      }

      button.success {
        background: #95e1d3;
      }

      button.success:hover {
        background: #7dc9b9;
      }

      .warning {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 15px 0;
      }

      .console {
        background: #1a1a2e;
        color: #eaeaea;
        padding: 15px;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-size: 0.9rem;
        height: 200px;
        overflow-y: auto;
        margin-top: 20px;
      }

      .console-title {
        color: #4ecdc4;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .console-entry {
        padding: 3px 0;
        border-bottom: 1px solid #30475e;
      }

      .feature-list {
        margin-top: 15px;
      }

      .feature-list li {
        margin-bottom: 8px;
        padding-left: 20px;
        position: relative;
      }

      .feature-list li:before {
        content: "✓";
        color: #4ecdc4;
        font-weight: bold;
        position: absolute;
        left: 0;
      }

      #todo-list {
        list-style-type: none;
        padding-left: 0;
        margin-top: 10px;
      }

      #todo-list li {
        padding: 5px 0;
        border-bottom: 1px dashed #eee;
      }

      @media (max-width: 768px) {
        .content {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>自定义 Vue3 响应式实现 (完整修复版)</h1>
        <div class="subtitle">基于 Proxy 的响应式系统 - 已修复数组响应式</div>
      </header>

      <div class="content">
        <div class="demo-section">
          <h2>对象响应式演示</h2>
          <p>使用 Proxy 代理对象，支持动态属性添加</p>

          <div class="data-display">
            <div>用户信息：</div>
            <div>姓名：<span id="name" class="highlight">未定义</span></div>
            <div>年龄：<span id="age" class="highlight">未定义</span></div>
            <div>职业：<span id="job" class="highlight">未定义</span></div>
            <div id="dynamic-property" style="display: none">
              动态属性：<span id="dynamic-value" class="highlight">无</span>
            </div>
          </div>

          <div class="button-group">
            <button onclick="App.changeName()">修改姓名</button>
            <button onclick="App.changeAge()">增加年龄</button>
            <button onclick="App.changeJob()">修改职业</button>
            <button class="success" onclick="App.addDynamicProperty()">
              动态添加属性
            </button>
            <button class="danger" onclick="App.deleteProperty()">
              删除属性
            </button>
          </div>

          <div class="warning">
            <strong>Vue3 优势：</strong> 支持动态添加和删除属性，无需特殊API
          </div>

          <div class="feature-list">
            <h3>Vue3 响应式特性：</h3>
            <ul>
              <li>基于 Proxy，支持动态属性</li>
              <li>支持数组索引直接修改</li>
              <li>惰性代理，性能更好</li>
              <li>无需 $set/$delete 方法</li>
            </ul>
          </div>
        </div>

        <div class="demo-section">
          <h2>数组响应式演示</h2>
          <p>Proxy 可以检测数组索引的直接修改</p>

          <div class="data-display">
            <div>待办事项：</div>
            <ul id="todo-list"></ul>
            <div>
              数组长度：<span id="array-length" class="highlight">0</span>
            </div>
            <div>
              已完成：<span id="completed-count" class="highlight">0</span>
            </div>
          </div>

          <div class="button-group">
            <button onclick="App.addTodo()">添加待办</button>
            <button onclick="App.removeTodo()">移除最后一项</button>
            <button onclick="App.updateTodoByIndex()">直接通过索引修改</button>
            <button onclick="App.toggleCompleted()">切换完成状态</button>
          </div>

          <div class="console">
            <div class="console-title">响应式系统日志：</div>
            <div id="console-log"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ==================== Vue3 响应式系统核心实现 (完整修复版) ====================

      // 修复核心：重写数组的变异方法以确保触发更新
      const arrayInstrumentations = {};

      // 需要重写的方法列表：这些方法会改变数组自身
      ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(
        (method) => {
          const original = Array.prototype[method];
          arrayInstrumentations[method] = function (...args) {
            // 1. 先执行原生的数组方法
            const result = original.apply(this, args);

            // 2. 获取这个数组对象的依赖映射
            const depsMap = targetMap.get(this);
            if (depsMap) {
              // 触发与 'length' 属性绑定的所有副作用函数
              const lengthDep = depsMap.get("length");
              if (lengthDep) {
                const effects = new Set(lengthDep);
                effects.forEach((effect) => effect());
              }

              // 对于 push 和 unshift 方法，新添加的元素也需要触发更新
              if (method === "push" || method === "unshift") {
                // 新元素从哪个索引开始
                const startIndex =
                  method === "push" ? this.length - args.length : 0;
                for (let i = 0; i < args.length; i++) {
                  const indexDep = depsMap.get(String(startIndex + i));
                  if (indexDep) {
                    const effects = new Set(indexDep);
                    effects.forEach((effect) => effect());
                  }
                }
              }

              // 对于 splice 方法，可能需要触发多个索引的更新
              if (method === "splice") {
                const start = args[0];
                const deleteCount = args[1] || 0;
                const itemsToAdd = args.slice(2);

                // 触发被删除元素的更新
                for (let i = start; i < start + deleteCount; i++) {
                  const indexDep = depsMap.get(String(i));
                  if (indexDep) {
                    const effects = new Set(indexDep);
                    effects.forEach((effect) => effect());
                  }
                }

                // 触发新增元素的更新
                for (let i = 0; i < itemsToAdd.length; i++) {
                  const indexDep = depsMap.get(String(start + i));
                  if (indexDep) {
                    const effects = new Set(indexDep);
                    effects.forEach((effect) => effect());
                  }
                }
              }
            }

            return result;
          };
        }
      );

      // 缓存已代理的对象，避免重复代理和无限递归
      const reactiveMap = new WeakMap();
      const targetMap = new WeakMap(); // 存储目标对象到其属性依赖映射的关系
      let activeEffect = null;

      // 追踪依赖：建立属性与副作用函数的关系
      function track(target, key) {
        if (activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            depsMap = new Map();
            targetMap.set(target, depsMap);
          }
          let dep = depsMap.get(key);
          if (!dep) {
            dep = new Set();
            depsMap.set(key, dep);
          }
          if (!dep.has(activeEffect)) {
            dep.add(activeEffect);
          }
        }
      }

      // 触发更新：当属性值变化时，执行所有相关的副作用函数
      function trigger(target, key) {
        const depsMap = targetMap.get(target);
        if (!depsMap) return;

        const dep = depsMap.get(key);
        if (dep) {
          const effects = new Set(dep);
          effects.forEach((effect) => effect());
        }

        // 如果是数组的索引被设置，也需要触发 length 的更新（在直接设置超出当前长度的索引时）
        if (
          Array.isArray(target) &&
          typeof key === "string" &&
          /^\d+$/.test(key)
        ) {
          const index = Number(key);
          if (index >= target.length - 1) {
            const lengthDep = depsMap.get("length");
            if (lengthDep) {
              const effects = new Set(lengthDep);
              effects.forEach((effect) => effect());
            }
          }
        }
      }

      // 创建响应式对象
      function reactive(obj) {
        // 基本类型直接返回
        if (typeof obj !== "object" || obj === null) return obj;

        // 如果已经是代理对象，直接返回
        if (obj.__isProxy) return obj;

        // 如果已经代理过，返回缓存的代理
        if (reactiveMap.has(obj)) return reactiveMap.get(obj);

        const handler = {
          get(target, key, receiver) {
            // 特殊属性标识
            if (key === "__isProxy") return true;

            // 关键修复：如果是数组且访问的是我们重写的方法，返回重写后的版本
            if (
              Array.isArray(target) &&
              arrayInstrumentations.hasOwnProperty(key)
            ) {
              return arrayInstrumentations[key];
            }

            const result = Reflect.get(target, key, receiver);

            // 依赖收集
            track(target, key);

            // 如果结果是对象，递归代理
            if (typeof result === "object" && result !== null) {
              // 避免自引用导致的无限递归
              if (result === target) return proxy;
              return reactive(result);
            }

            return result;
          },

          set(target, key, value, receiver) {
            const oldValue = target[key];
            const hasKey = Object.prototype.hasOwnProperty.call(target, key);

            const result = Reflect.set(target, key, value, receiver);

            // 只有当设置成功且值确实变化时才触发更新
            if (result && value !== oldValue) {
              trigger(target, key);

              // 对于数组，设置新索引时需要触发 length 更新
              if (
                Array.isArray(target) &&
                typeof key === "string" &&
                /^\d+$/.test(key)
              ) {
                const index = Number(key);
                // 如果设置的索引超出了当前数组长度，需要触发 length 更新
                if (index >= target.length) {
                  trigger(target, "length");
                }
              }
            }

            return result;
          },

          deleteProperty(target, key) {
            const hasKey = Object.prototype.hasOwnProperty.call(target, key);
            const oldValue = target[key];

            const result = Reflect.deleteProperty(target, key);

            if (result && hasKey) {
              trigger(target, key);
            }

            return result;
          },
        };

        const proxy = new Proxy(obj, handler);
        reactiveMap.set(obj, proxy);
        return proxy;
      }

      // 副作用函数：建立响应式数据与渲染函数的关系
      function effect(fn) {
        const effectFn = () => {
          activeEffect = effectFn;
          const result = fn();
          activeEffect = null;
          return result;
        };

        effectFn();
        return effectFn;
      }

      // 简化的计算属性
      function computed(getter) {
        let value;
        let dirty = true;

        const effectFn = effect(() => {
          value = getter();
        });

        return {
          get value() {
            return getter();
          },
        };
      }

      // ==================== 应用程序代码 ====================
      window.App = {
        user: null,
        todos: null,
        completedCount: null,

        init() {
          try {
            // 初始化响应式数据
            this.user = reactive({
              name: "李四",
              age: 30,
              job: "全栈工程师",
            });

            this.todos = reactive([
              { id: 1, text: "学习Vue3原理", completed: false },
              { id: 2, text: "编写示例代码", completed: true },
              { id: 3, text: "测试Proxy响应式", completed: false },
            ]);

            // 计算属性
            this.completedCount = computed(() => {
              return this.todos.filter((todo) => todo.completed).length;
            });

            // 设置自动渲染
            this.setupAutoRender();

            // 初始渲染
            this.renderUserInfo();
            this.renderTodoList();

            this.logToConsole("Vue3响应式系统初始化成功！");
            this.logToConsole(
              "修复说明：已重写数组的 push/pop 等方法，确保能触发响应式更新。"
            );
            this.logToConsole("现在所有功能均可正常使用：");
            this.logToConsole("1. 对象属性修改");
            this.logToConsole("2. 动态属性添加/删除");
            this.logToConsole("3. 数组操作（添加、删除、索引修改等）");
          } catch (error) {
            this.logToConsole(`初始化失败: ${error.message}`);
            console.error("初始化错误:", error);
          }
        },

        setupAutoRender() {
          // 用户信息自动渲染
          effect(() => {
            this.renderUserInfo();
          });

          // 待办列表自动渲染
          effect(() => {
            this.renderTodoList();
          });
        },

        renderUserInfo() {
          try {
            const nameEl = document.getElementById("name");
            const ageEl = document.getElementById("age");
            const jobEl = document.getElementById("job");

            if (this.user) {
              if (nameEl) nameEl.textContent = this.user.name;
              if (ageEl) ageEl.textContent = this.user.age;
              if (jobEl) jobEl.textContent = this.user.job;

              // 动态属性显示
              const dynamicValueEl = document.getElementById("dynamic-value");
              const dynamicPropertyEl =
                document.getElementById("dynamic-property");

              if (dynamicValueEl && dynamicPropertyEl) {
                const dynamicProps = ["salary", "hobby", "email", "phone"];
                const hasDynamicProp = dynamicProps.some(
                  (prop) => this.user[prop] !== undefined
                );

                if (hasDynamicProp) {
                  for (const prop of dynamicProps) {
                    if (this.user[prop] !== undefined) {
                      dynamicValueEl.textContent = `${prop}: ${this.user[prop]}`;
                      dynamicPropertyEl.style.display = "block";
                      break;
                    }
                  }
                } else {
                  dynamicValueEl.textContent = "无";
                  dynamicPropertyEl.style.display = "none";
                }
              }
            }
          } catch (error) {
            console.error("渲染用户信息出错:", error);
          }
        },

        renderTodoList() {
          try {
            const todoListEl = document.getElementById("todo-list");
            const arrayLengthEl = document.getElementById("array-length");
            const completedCountEl = document.getElementById("completed-count");

            if (this.todos && todoListEl) {
              todoListEl.innerHTML = "";

              this.todos.forEach((todo, index) => {
                const li = document.createElement("li");
                li.innerHTML = `
                                ${index + 1}. 
                                <span style="text-decoration: ${
                                  todo.completed ? "line-through" : "none"
                                }; 
                                            color: ${
                                              todo.completed ? "#888" : "#333"
                                            }">
                                    ${todo.text}
                                </span>
                                <small style="margin-left: 8px;">${
                                  todo.completed ? "✅ 完成" : "⭕ 未完成"
                                }</small>
                            `;
                todoListEl.appendChild(li);
              });

              if (arrayLengthEl) {
                arrayLengthEl.textContent = this.todos.length;
              }
            }

            if (this.completedCount && completedCountEl) {
              completedCountEl.textContent = this.completedCount.value;
            }
          } catch (error) {
            console.error("渲染待办列表出错:", error);
          }
        },

        // 对象操作方法
        changeName() {
          if (!this.user) {
            this.logToConsole("错误：用户数据未初始化");
            return;
          }
          const names = ["李四", "王五", "赵六", "钱七"];
          this.user.name = names[Math.floor(Math.random() * names.length)];
        },

        changeAge() {
          if (!this.user) {
            this.logToConsole("错误：用户数据未初始化");
            return;
          }
          this.user.age += 1;
        },

        changeJob() {
          if (!this.user) {
            this.logToConsole("错误：用户数据未初始化");
            return;
          }
          const jobs = ["全栈工程师", "前端架构师", "技术总监", "产品经理"];
          this.user.job = jobs[Math.floor(Math.random() * jobs.length)];
        },

        addDynamicProperty() {
          if (!this.user) {
            this.logToConsole("错误：用户数据未初始化");
            return;
          }
          const properties = [
            ["salary", Math.floor(Math.random() * 10000) + 5000],
            [
              "hobby",
              ["编程", "阅读", "运动", "音乐"][Math.floor(Math.random() * 4)],
            ],
            ["email", `user${Math.floor(Math.random() * 1000)}@example.com`],
            ["phone", `138${Math.floor(Math.random() * 100000000)}`],
          ];

          const [key, value] =
            properties[Math.floor(Math.random() * properties.length)];
          this.user[key] = value;
        },

        deleteProperty() {
          if (!this.user) {
            this.logToConsole("错误：用户数据未初始化");
            return;
          }
          const properties = ["salary", "hobby", "email", "phone"].filter(
            (prop) => this.user[prop] !== undefined
          );

          if (properties.length > 0) {
            const propToDelete =
              properties[Math.floor(Math.random() * properties.length)];
            delete this.user[propToDelete];
            this.logToConsole(`已删除属性: ${propToDelete}`);
          } else {
            this.logToConsole("没有可删除的动态属性");
          }
        },

        // 数组操作方法 - 现在所有方法都能正常触发响应式更新
        addTodo() {
          if (!this.todos) {
            this.logToConsole("错误：待办数据未初始化");
            return;
          }
          const newTodos = [
            { id: Date.now(), text: "学习Composition API", completed: false },
            { id: Date.now(), text: "理解Proxy原理", completed: false },
            { id: Date.now(), text: "实现响应式系统", completed: false },
          ];

          const newTodo = newTodos[Math.floor(Math.random() * newTodos.length)];
          // 关键修复：现在 push 方法会触发响应式更新
          this.todos.push(newTodo);
          this.logToConsole(
            `添加新任务: ${newTodo.text} (长度: ${this.todos.length})`
          );
        },

        removeTodo() {
          if (!this.todos || this.todos.length === 0) {
            this.logToConsole("错误：没有可删除的任务");
            return;
          }
          const removed = this.todos.pop();
          this.logToConsole(
            `移除任务: ${removed.text} (长度: ${this.todos.length})`
          );
        },

        updateTodoByIndex() {
          if (!this.todos || this.todos.length === 0) {
            this.logToConsole("错误：没有可修改的任务");
            return;
          }
          const index = Math.floor(Math.random() * this.todos.length);
          const newTexts = ["已更新任务", "重新安排任务", "优化后的任务"];
          const newText =
            newTexts[Math.floor(Math.random() * newTexts.length)] + (index + 1);

          // 直接通过索引修改 - Vue3 原生支持
          this.todos[index].text = newText;
          this.logToConsole(`直接修改数组索引 ${index}: ${newText} (Vue3特性)`);
        },

        toggleCompleted() {
          if (!this.todos || this.todos.length === 0) {
            this.logToConsole("错误：没有可修改的任务");
            return;
          }
          const index = Math.floor(Math.random() * this.todos.length);
          const oldStatus = this.todos[index].completed;
          this.todos[index].completed = !oldStatus;
          this.logToConsole(
            `任务 ${index + 1} 状态: ${
              oldStatus ? "完成→未完成" : "未完成→完成"
            }`
          );
        },

        logToConsole(message) {
          try {
            const consoleEl = document.getElementById("console-log");
            if (consoleEl) {
              const entry = document.createElement("div");
              entry.className = "console-entry";
              entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
              consoleEl.appendChild(entry);
              consoleEl.scrollTop = consoleEl.scrollHeight;
            }
          } catch (error) {
            console.error("写入日志失败:", error);
          }
        },
      };

      // 页面加载完成后初始化应用
      document.addEventListener("DOMContentLoaded", function () {
        // 等待一小段时间确保所有元素都加载完成
        setTimeout(() => {
          App.init();
        }, 100);
      });
    </script>
  </body>
</html>

